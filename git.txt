----------------------------------------------------------------------------------------------
安装Git
----------------------------------------------------------------------------------------------
在Linux上安装Git
	$ git ##先输入git
	The program 'git' is currently not installed. You can install it by typing:
	sudo apt-get install git ##没有安装Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。
	
	##老一点的Debian或Ubuntu Linux，要把命令改为
	sudo apt-get install git-core

	通过源码安装。先从Git官网下载源码，然后解压，依次输入：
	./config，make，sudo make install ##这几个命令安装就好了。

在Windows上安装Git
	https://git-for-windows.github.io/
	http://git-scm.com/download/win

配置git
	$ git config --global user.name "Your Name"
	$ git config --global user.email "email@example.com"
	--global参数，表示你这台机器上所有的Git仓库都会使用这个配置
	
个人学习的话，建议直接上ubuntu，apt简单易用，软件更新及时。RHEL的软件更新实在太慢


----------------------------------------------------------------------------------------------
创建版本库
----------------------------------------------------------------------------------------------
##建立空目录
	$ mkdir learngit
	$ cd learngit
	$ pwd		##pwd命令用于显示当前目录。
	/Users/michael/learngit
##把目录变成Git可以管理的仓库：
	$ git init
	Initialized empty Git repository in /Users/michael/learngit/.git/
	##如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。
	
##把文件添加到暂存区：
	$ git add readme.txt
	
##把文件提交到仓库：
	$ git commit -m "wrote a readme file"  ##参数"-m"后面输入的是本次提交的说明.
	[master (root-commit) cb926e7] wrote a readme file
	1 file changed, 2 insertions(+)
	create mode 100644 readme.txt
	
	
##小结
	在总结一下今天学的两点内容：
	初始化一个Git仓库，使用git init命令。
	添加文件到Git仓库，分两步：
	第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；
	第二步，使用命令git commit，完成。
	
	省略<path>表示.,即当前目录。
	git add <path>的形式把我们<path>添加到索引库中，<path>可以是文件也可以是目录。
	git add -u [<path>]: 把<path>中所有tracked文件中被修改过或已删除文件的信息添加到索引库。它不会处理untracted的文件。
	git add -A: [<path>]表示把<path>中所有tracked文件中被修改过或已删除文件和所有untracted的文件信息添加到索引库。
	git add --all
	git add -i [<path>]命令查看<path>中被所有修改过或已删除文件但没有提交的文件，
		并通过其revert子命令可以查看<path>中所有untracted的文件，同时进入一个子命令系统。
		比如：
		git add -i
					 staged      unstaged path
			1:        +0/-0      nothing branch/t.txt
			2:        +0/-0      nothing branch/t2.txt
			3:    unchanged        +1/-0 readme.txt

			Commands 
			1: [s]tatus     2: [u]pdate     3: [r]evert     4: [a]dd untracked
			5: [p]atch      6: [d]iff       7: [q]uit       8: [h]elp
			What now>
			这里的t.txt和t2.txt表示已经被执行了git add，待提交。即已经添加到索引库中。
			readme.txt表示已经处于tracked下，它被修改了，但是还没有被执行了git add。即还没添加到索引库中。
			
	在错误的目录打了git init命令,把.git目录剪切出/删除即可。

##PS:所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等.
	 可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。
	 
	 而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，
	 只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，
	 版本控制系统不知道，也没法知道。
	 
	 Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的.
	 如果要真正使用版本控制系统，就要以纯文本方式编写文件。强烈建议使用标准的UTF-8编码，
	 所有语言使用同一种编码，既没有冲突，又被所有平台所支持。
	 
##PS:使用Windows的童鞋要特别注意：
	 Windows自带的记事本保存UTF-8编码文件时会在文件开头添加了0xefbbbf（十六进制）的字符，
	 你会遇到很多不可思议的问题比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等
	 建议下载Notepad++代替记事本，记得把Notepad++的默认编码设置为UTF-8 without BOM即可。
	 https://notepad-plus-plus.org/
	 
	 
----------------------------------------------------------------------------------------------
时光机穿梭
----------------------------------------------------------------------------------------------
	$ git status	##命令可以让我们时刻掌握仓库当前的状态.
	$ git diff readme.txt 	##git diff顾名思义就是查看difference##差异##
							##比较工作区与暂存区/库仓，readme.txt文件的差异。
							##比较还没有add的文件与已经add过的文件的区别。
							
##小结
	要随时掌握工作区的状态，使用git status命令。
	如果git status告诉你有文件被修改过，用git diff可以查看修改内容。
	
##PS:git --help commit可以看到怎么使用.

----------------------------------------------------------------------------------------------
版本回退
----------------------------------------------------------------------------------------------
$ git log		##查看历史记录
				##git log --pretty=oneline参数。简略显示。
$ git reflog	##查看命令的历史记录。

$ git reset --hard			##查看当前HEAD指针指向的版本号,并工作区文件恢复到该版本号。
$ git reset --hard HEAD^	##恢复到上个版本
$ git reset --hard HEAD^^	##恢复到上上个版本
$ git reset --hard HEAD~100	##恢复到前100个版本
$ git reset --hard 3628164	##恢复到指写的commit id
							##commit id==>3628164
$ git reset HEAD readme.txt	##把暂存区的修改撤销掉（unstage）.工作区文件内容不变。

$ cat readme.txt	##查看readme.txt文件。

##小结##
现在总结一下：

HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。

穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。

要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。

----------------------------------------------------------------------------------------------
工作区和暂存区
----------------------------------------------------------------------------------------------
工作区（Working Directory） ##就是在电脑里能看到的目录,比如learngit文件夹.

版本库（Repository）		##隐藏目录.git是Git的版本库。
							##其中最重要的就是称为stage（或者叫index）的暂存区，
							  自动创建的第一个分支master，以及指向master的一个指针叫HEAD。

前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：
	第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；
	第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。
	
##PS##
	git diff --cached	##命令对比暂存区和最近一次提交的不同
	暂存区就像购物车，没到付款的时候你都不确定购物车里的东西全部都是要的。。


----------------------------------------------------------------------------------------------
管理修改
----------------------------------------------------------------------------------------------
$ git diff HEAD -- readme.txt ##命令可以查看工作区和版本库里面最新版本的区别：
								readme.txt<==查看的文件名.
								
git diff：是查看working tree与index file的差别的。
git diff --cached：是查看index file与commit的差别的。
git diff HEAD：是查看working tree和commit的差别的。（你一定没有忘记，HEAD代表的是最近的一次commit的信息）

git commit readme.txt -m "..."	##提交到暂存区后直接提交到分支，两步一起完成？？？？？？

##PS##
	-- 指定文件可以提交未保存到暂存区(unstaged)
	vi readme.txt
	git commit readme.txt -m "commit with unstaged modify"
	vi readme.txt
	git commit -a -m "commit all file will commit unstaged modify"

	--不使用其他参数不会提交unstaged modify
	git commit -m "commit without param will not commit unstaged modify"

	
----------------------------------------------------------------------------------------------
撤销修改
----------------------------------------------------------------------------------------------
$ git checkout -- readme.txt	##丢弃工作区的修改。
		##有两种情况：
		  一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
		  一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
	
	git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令
	

$ git reset HEAD readme.txt		##把暂存区的修改撤销掉（unstage）.
								##git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。
								  当我们用HEAD时，表示最新的版本。
								  
##小结##

场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。

场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步。
	   第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。

场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。

##PS##
	1.撤销工作区的修改符合就近原则：
	工作区 < - 缓冲区 <- 版本库
	撤销工作区修改，如果缓冲区有该文件，则checkout -- file 会将缓冲区的内容覆盖到工作区，
	此时工作区和缓冲区文件内容相同，因此工作区是干净的，并没有未add的文件。
	
	撤销工作区修改，如果缓冲区没有该文件，则checkout -- file命令会继续向上找，找到版本库中的该文件，
	此时使用版本库中的文件覆盖工作区，工作区不干净，因为有未提交的文件（从版本库中覆盖修改的文件）。

	2.撤销缓冲区
	git reset HEAD readme.txt
	直接丢弃缓冲区中的相应内容，只剩下工作区的版本。缓冲区中内容并没有覆盖到工作区，而是直接清除。
		
----------------------------------------------------------------------------------------------
删除文件
----------------------------------------------------------------------------------------------
##文件已经被提交到版本库，那么不用担心误删，你能恢复文件到(版本库)最新版本.

$ git checkout -- test.txt	##从版本库恢复文件到工作区

$ git rm test.txt					##删除版本库中的文件。
$ git commit -m "remove test.txt"	##提交删除操作。


----------------------------------------------------------------------------------------------
远程仓库
----------------------------------------------------------------------------------------------

创建SSH Key。
###在<用户主目录>下,看看有没有.ssh目录，里面有没有id_rsa和id_rsa.pub这两个文件，有，直接跳到下一步。
##id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。

$ ssh-keygen -t rsa -C "youremail@example.com"	##youremail@example.com改为自已的邮箱地址。

##登陆GitHub，在右上角点击菜单选择"settings"，点击"SSH Keys"页面：
  点"Add SSH Key"按键，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。
  点"Add Key"按键

  因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，
  所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。
 
##验证是否配置成功 
$ ssh -T git@github.com
如果配置成功，则会显示：
Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.

----------------------------------------------------------------------------------------------
添加远程库
----------------------------------------------------------------------------------------------
#1#登陆GitHub-->右上角"+"-->"new repository"按钮
#2#在Repository 填入库仓名-->"Create repository"按钮

$ git remote add origin git@github.com:won2930015/git_test.git	##ssh方式(推介)本地仓库与远程库关联
											##OR##
$ git remote add origin https://github.com/won2930015/git_test.git	##https方式(需帐号密码)。本地仓库与远程库关联
$ git push -u origin master		##本地仓库内容推送至GitHub仓库。(PS:origin：库仓名，master：分支名称。)

##以后推送简化为：
$ git push origin master

$ git remote rm origin	##删除本地仓库与远程仓库的关联

添加后，origin是库的名字，可以改成别的，但是origin这个名字一看就知道是远程库。

##由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支
  内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，
  在以后的推送或者拉取时就可以简化命令。

##小结##
要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；
关联后，使用命令git push -u origin master第一次推送master分支的所有内容；
此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；

----------------------------------------------------------------------------------------------
从远程库克隆
----------------------------------------------------------------------------------------------
##1##创建库
登陆GitHub，创建一个新的仓库，名字叫test
勾选Initialize this repository with a README，GitHub会为我们创建一个README.md文件。

##2##克隆远程库
$ git clone git@github.com:won2930015/test.git

----------------------------------------------------------------------------------------------
分支管理
----------------------------------------------------------------------------------------------
分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。

如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，
你既学会了Git又学会了SVN！

----------------------------------------------------------------------------------------------
创建与合并分支
----------------------------------------------------------------------------------------------
$ git checkout -b dev	##创建dev分支，并切换到dev分支。-b参数表示创建并切换。
					##OR##	  
$ git branch dev		##创建dev分支
$ git checkout dev		##切换到dev分支

$ git branch			##命令查看当前分支：当前分支用*号标注。
* dev
  master
##↓↓↓↓↓↓修改文件后↓↓↓↓↓↓##
$ git checkout master	##切换回master分支.

$ git merge dev			##合并指定分支到当前分支。
Updating d17efd8..fec145a
Fast-forward	##<-------Git告诉我们，这次合并是“快进模式”，
 readme.txt |    1 +
 1 file changed, 1 insertion(+)
  
$ git branch -d dev		##删除dev分支.
 
##小结##
Git鼓励大量使用分支：

查看分支：git branch

创建分支：git branch <name>

切换分支：git checkout <name>

创建+切换分支：git checkout -b <name>

合并某分支到当前分支：git merge <name>

删除分支：git branch -d <name>

----------------------------------------------------------------------------------------------
解决冲突
----------------------------------------------------------------------------------------------
#1#创建分支feature1##
$ git checkout -b feature1

##修改readme.txt最后一行，改为：Creating a new branch is quick AND simple.

git add readme.txt
git commit -m "AND simple"

#2#切换到分支master##
$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 1 commit.
##Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。

##在master分支上把readme.txt文件的最后一行改为：Creating a new branch is quick & simple.

$ git add readme.txt 
$ git commit -m "& simple"

$ git merge feature1	##合并feature1分支
Auto-merging readme.txt
CONFLICT (content): Merge conflict in readme.txt
Automatic merge failed; fix conflicts and then commit the result.
果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。

git status		##也可以告诉我们冲突的文件：

Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
<<<<<<< HEAD
Creating a new branch is quick & simple.
=======
Creating a new branch is quick AND simple.
>>>>>>> feature1

Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容。我们修改如下后保存：

##我们修改后保存：Creating a new branch is quick and simple.

$ git add readme.txt 
$ git commit -m "conflict fixed"

$ git branch -d feature1		##删除feature1分支。

git log --graph		##查看分支合并图。

----------------------------------------------------------------------------------------------
分支管理策略
----------------------------------------------------------------------------------------------

$ git merge --no-ff -m "merge with no-ff" dev  ##dev分支名，--no-ff参数，表示禁用Fast forward模式
											   ##因为本次合并要创建一个新的commit，所以加上-m参数，
											     把commit描述写进去。合并后，我们用git log --graph看看分支
												 
##PS##
--no-ff参数作用：为了便于问题定位，区分两个分支的 commit 信息，使得版本演进过程更清晰，
				 在出现问题之后可定位错误点、退回之前的修改版本。
				 
###-ff和--no-ff的结果都是一样的,都会合并,其最大区别在于,-ff会"默默"地合并,其仅仅是将指针移动到分支的最新处
 (当然删除分支并不会对master产生任何影响),而--no-ff则是重新建立了一个commit,然后将合并当做一个comiit来处理,
  自然就产生了合并的信息.所以,可想而知,如果你的master很重要,某一次合并后出现问题,而你又是使用-ff,
  这里没有任何记录可以让你回退版本的!(回退只有靠commit id).

##分支策略##

在实际开发中，我们应该按照几个基本原则进行分支管理：
首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；

干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；

你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。
												 
##小结##
##合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，
  而fast forward合并就看不出来曾经做过合并。
  
##PS##
两个问题想请教一下廖总

① 假如要参加一个github上的开源项目，先从github上clone到本地rep，然后创建dev分支，完成代码以后merge带=到本地的master，
   这个时候如果push origin，是否接受修改是不是由github上的项目库的作者决定？

② 关于多人分工参与一个项目。在master不变的情况下，创建一个dev分支，大家都在dev上工作，具体是怎样操作的？
   是不是每个人都会先创建自己的本地仓库，内容是直接clone的远程dev，那如果几个人参与的是同一段代码，
   如果push到远端进行merge？

		1 - 如果你不是项目组的成员，github不会让你push，所以必须先在github clone一个你自己的repo

		2 - 如果决定都在dev分支开发，得有一个人先在本地创建dev，push到github，其他人从github pull下来就有dev分支了
            如果merge有冲突，你是push不上去的，必须先pull下来，解决冲突，才能push，所以不存在同时push的冲突问题
			
① GitHub上能如何能看到类似的分支历史流程图？
		1 - 进入项目，点击右侧的Graphs，选择Network标签。